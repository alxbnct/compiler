module Main exposing (main)

import Node
import ChildProcess
import Init
import Stream exposing (Stream)
import Task exposing (Task)
import Dict exposing (Dict)
import FileSystem
import FileSystem.Path as Path exposing (Path)
import HttpClient
import Bytes exposing (Bytes)
import Terminal
import Process
import CLI.Parser
import CLI.PrettyPrinter as PP



main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_model -> Sub.none
        }


compilerVersion : String
compilerVersion =
    "0.4.5"


cliParser : CLI.Parser.App Command
cliParser =
    { name = "gren"
    , version = compilerVersion
    , intro = 
        PP.verticalBlock
            [ PP.block
                [ PP.text "Hi, thank you for trying out "
                , PP.intenseColor PP.Green <| PP.text ("Gren " ++ compilerVersion)
                , PP.text ". I hope you like it!"
                ]
            , PP.empty
            , PP.intenseColor PP.Black <|
                PP.text
                    """
                    -------------------------------------------------------------------------------
                    I highly recommend working through <https://gren-lang.org/learn> to get started
                    It teaches many important concepts, including how to use `gren` in the terminal
                    -------------------------------------------------------------------------------
                    """
            ]
    , outro = 
        PP.words
            """
            Be sure to ask on the Gren Discord (https://discord.gg/Chb9YB9Vmh) if you run into trouble!
            Folks are friendly and happy to help out. They hang out there because it is fun, so be kind
            to get the best results!
            """
    , commands =
        CLI.Parser.defineGroup
            |> CLI.Parser.withCommand
                { word = "init"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags 
                        (\package platform ->
                            { package = package
                            , platform = platform
                            }
                        )
                        |> CLI.Parser.toggle "package" "Create a package (as opposed to an application)"
                        |> CLI.Parser.flag "platform" initPlatformParser "Which platform to target"
                , commonDescription =
                    Just "Start a Gren project. It creates a starter gren.json file."
                , summary =
                    "The `init` command helps start Gren project:"
                , example = 
                    PP.words
                        """
                        It will ask permission to create a gren.json file, the one thing
                        common to all Gren project.
                        """
                , builder =
                    \args _flags -> Init args
                }
            |> CLI.Parser.withCommand
                { word = "repl"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags identity
                        |> CLI.Parser.flag "interpreter" interpreterParser "Path to a alternate JS interpreter, like deno or nodejs."
                , commonDescription =
                    Just 
                        """
                        Open up an interactive programming session. Type in Gren expressions like
                        (2 + 2) or (String.length \"test\") and see if they equal four!
                        """
                , summary =
                    "The `repl` command opens up an interactive programming session:"
                , example = 
                    PP.words
                        """
                        Start working through <https://gren-lang.org/learn> to learn how to use this!
                        It has a whole chapter that uses the REPL for everything, so that is probably
                        the quickest way to get started.
                        """
                , builder =
                    \_args flags -> Repl flags
                }
            |> CLI.Parser.withCommand
                { word = "make"
                , arguments =
                    CLI.Parser.zeroOrMoreArgs CLI.Parser.grenFileParser
                , flags =
                    CLI.Parser.initFlags 
                        (\debug optimize sourcemaps output report ->
                            { debug = debug
                            , optimize = optimize
                            , sourcemaps = sourcemaps
                            , output = output
                            , report = report
                            }
                        )
                        |> CLI.Parser.toggle "debug" "Turn on the time-travelling debugger for applications targetting the browser platform. It allows you to rewind and replay events. The events can be imported/exported into a file, which makes for very precise bug reports!"
                        |> CLI.Parser.toggle "optimize" "Turn on optimizations to make code smaller and faster. For example, the compiler renames record fields to be as short as possible and unboxes values to reduce allocation."
                        |> CLI.Parser.toggle "sourcemaps" "Add sourcemaps to the resulting JS file. This let's you debug Gren code in a JS debugger, at the cost of longer compile times and a bigger JS file."
                        |> CLI.Parser.flag "output" CLI.Parser.pathParser "Specify the name of the resulting JS file. For example --output=assets/gren.js to generate the JS at assets/gren.js. You can also use --output=/dev/stdout to output the JS to the terminal, or --output=/dev/null to generate no output at all!"
                        |> CLI.Parser.flag "report" CLI.Parser.pathParser "You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!"
                , commonDescription =
                    Nothing
                , summary =
                    "The `make` command compiles Gren code into JS or HTML:"
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.words "gren make src/Main.gren"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.words
                            """
                            This tries to compile an Gren file named src/Main.gren, generating an index.html
                            file if possible.
                            """
                        ]
                , builder =
                    \args flags -> Make args flags
                }
            |> CLI.Parser.withCommand
                { word = "docs"
                , arguments =
                    CLI.Parser.noArgs
                , flags =
                    CLI.Parser.initFlags 
                        (\output report ->
                            { output = output
                            , report = report
                            }
                        )
                        |> CLI.Parser.flag "output" CLI.Parser.pathParser "Specify the name of the resulting JSON file. For example --output=assets/docs.json to generate the JSON at assets/docs.json. You can also use --output=/dev/stdout to output the JSON to the terminal, or --output=/dev/null to verify that generating the documentation would work."
                        |> CLI.Parser.flag "report" CLI.Parser.pathParser "You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!"
                , commonDescription =
                    Nothing
                , summary =
                    "The `docs` command collects all documentation for a package in a JSON file:"
                , example = 
                    PP.verticalBlock
                        [ PP.words "For example:"
                        , PP.words "gren docs"
                            |> PP.indent
                            |> PP.color PP.Green
                        , PP.words
                            """
                            This collects all documentation for the current pacage and writes it to a
                            docs.json file, if possible.
                            """
                        ]
                , builder =
                    \_args flags -> Docs flags
                }
    }


type Command
    = Init InitFlags
    | Repl ReplFlags
    | Make MakeFlags (Array String)
    | Docs DocsFlags


type alias InitFlags =
    {
    }


type alias ReplFlags =
    {
    }


type alias MakeFlags =
    {
    }


type alias DocsFlags =
    { output : String
    , report : String
    }

type alias Model = 
    { args : Array String
    , stdout : Stream
    , stderr : Stream
    , useColor : Bool
    , fsPermission : FileSystem.Permission
    , cpPermission : ChildProcess.Permission
    , httpPermission : HttpClient.Permission
    , remotePath : Maybe String
    , localPath : Path
    , pathToString : Path -> String
    }


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await FileSystem.initialize <| \fsPermission ->
    Init.await ChildProcess.initialize <| \cpPermission ->
    Init.await HttpClient.initialize <| \httpPermission ->
    Init.await Terminal.initialize <| \terminalConfig ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
    Init.awaitTask (FileSystem.homeDirectory fsPermission) <| \homeDir ->
            let
                userArgs =
                    Array.dropFirst 2 env.args

                useColor =
                    case terminalConfig of
                        Nothing ->
                            False

                        Just _ ->
                            case Dict.get "NO_COLOR" envVars of
                                Just _ ->
                                    False

                                Nothing ->
                                    True

                maybePaths =
                    case { platform = env.platform, arch = env.cpuArchitecture, override = Dict.get "GREN_BIN" envVars } of
                        { override = Just overridePath, platform = Node.Win32 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Nothing
                                , localPath = Path.fromWin32String overridePath
                                }
                        
                        { override = Just overridePath } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Nothing
                                , localPath = Path.fromPosixString overridePath
                                }
                                
                        { platform = Node.Win32, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Just <| makeRemotePath "gren.exe"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Darwin, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Just <| makeRemotePath "gren_mac"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Darwin, arch = Node.Arm64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Just <| makeRemotePath "gren_mac_aarch64"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        { platform = Node.Linux, arch = Node.X64 } ->
                            Just <|
                                { args = userArgs
                                , stdout = env.stdout
                                , remotePath = Just <| makeRemotePath "gren_linux"
                                , localPath = makeLocalPath env.platform homeDir envVars
                                }

                        _ ->
                            Nothing

                model =
                    case maybePaths of
                        Just paths ->
                            { args = userArgs
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , useColor = useColor
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , httpPermission = httpPermission
                            , remotePath = paths.remotePath
                            , localPath = paths.localPath
                            , pathToString =
                                if env.platform == Node.Win32 then
                                    Path.toWin32String
                                else
                                    Path.toPosixString
                            }
                        
                        Nothing ->
                            -- dummy model
                            { args = []
                            , stdout = env.stdout
                            , stderr = env.stderr
                            , useColor = useColor
                            , fsPermission = fsPermission
                            , cpPermission = cpPermission
                            , httpPermission = httpPermission
                            , remotePath = Nothing
                            , localPath = Path.empty
                            , pathToString = Path.toPosixString
                            }
            in
            Node.startProgram
                { model = model
                , command =
                    case maybePaths of
                        Just _ ->
                            case CLI.Parser.run userArgs cliParser of
                                CLI.Parser.UnknownCommand commandName ->
                                    Stream.sendLine env.stderr ("I don't recognize this command: " ++ commandName)
                                        |> Task.execute
                                
                                CLI.Parser.BadFlags err ->
                                    Stream.sendLine env.stderr "BadFlag"
                                        |> Task.execute
                                
                                CLI.Parser.BadArguments err ->
                                    Stream.sendLine env.stderr "BadArgument"
                                        |> Task.execute
                                
                                CLI.Parser.HelpText prettifiedText ->
                                    prettifiedText
                                        |> PP.toStringWithOptions
                                            { PP.defaultOptions | maxColumns = 80 }
                                        |> Stream.sendLine env.stdout
                                        |> Task.execute
                                
                                CLI.Parser.Success command ->
                                    FileSystem.checkAccess fsPermission [] model.localPath
                                        |> Task.attempt ExistanceChecked

                        Nothing ->
                            Stream.sendLine env.stderr "We currently don't support this platform/arch."
                                |> Task.execute
                }


makeRemotePath : String -> String
makeRemotePath filename =
    String.join "/"
        [ "https://github.com/gren-lang/compiler/releases/download"
        , compilerVersion
        , filename
        ]


makeLocalPath : Node.Platform -> Path -> Dict String String -> Path
makeLocalPath platform homeDir envVars =
    let
        startPath =
            case platform of
                Node.Win32 ->
                    envVars
                        |> Dict.get "LOCALAPPDATA"
                        |> Maybe.map Path.fromWin32String
                        |> Maybe.withDefault (
                            "AppData/Local"
                                |> Path.fromPosixString
                                |> Path.prepend homeDir
                            )

                Node.Darwin ->
                    "Library/Caches"
                        |> Path.fromPosixString
                        |> Path.prepend homeDir

                _ ->
                    envVars
                        |> Dict.get "XDG_CACHE_HOME"
                        |> Maybe.map Path.fromPosixString
                        |> Maybe.withDefault (Path.append (Path.fromPosixString ".cache") homeDir)

        filename =
            case platform of
                Node.Win32 ->
                    "gren.exe"

                _ ->
                    "gren"
        
        endPath =
            [ "gren"
            , compilerVersion
            , "bin"
            , filename
            ]
                |> String.join "/"
                |> Path.fromPosixString
    in
    Path.prepend startPath endPath


type Msg
    = ExistanceChecked (Result FileSystem.Error Path)
    | CompilerDownloaded (Result (HttpClient.Error Bytes) (HttpClient.Response Bytes))
    | CompilerInstalled (Result FileSystem.Error {})
    | CompilerRan Int


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    case msg of
        ExistanceChecked (Err _) ->
            { model = model
            , command =
                case model.remotePath of
                    Just remotePath ->
                        Stream.sendLine model.stdout ("Compiler not found at " ++ model.pathToString model.localPath ++ ". Downloading...")
                            |> Task.andThen (\{} -> downloadBinary model.httpPermission remotePath)
                            |> Task.attempt CompilerDownloaded
                    
                    Nothing ->
                        Stream.sendLine model.stderr ("Compiler not found at " ++ model.pathToString model.localPath)
                            |> Task.execute
            }

        ExistanceChecked (Ok _) ->
            { model = model
            , command =
                runCompiler model
            }

        CompilerDownloaded (Err ((HttpClient.BadStatus res) as err)) ->
            if res.statusCode == 302 then
                case Dict.get "location" res.headers of
                    Just [ location ] ->
                        { model = model
                        , command =
                            downloadBinary model.httpPermission location
                                |> Task.attempt CompilerDownloaded
                        }

                    _ ->
                        { model = model
                        , command =
                            Stream.sendLine model.stderr "Missing, or vague, 'location' header in 302 response from server."
                                |> Task.execute
                        }

            else
                { model = model
                , command =
                    Stream.sendLine model.stderr (HttpClient.errorToString err)
                        |> Task.execute
                }
        
        CompilerDownloaded (Err err) ->
                { model = model
                , command =
                    Stream.sendLine model.stderr (HttpClient.errorToString err)
                        |> Task.execute
                }
        
        CompilerDownloaded (Ok res) ->
            let
                cacheFolder =
                    Path.parentPath model.localPath
                        |> Maybe.withDefault Path.empty
            in
            { model = model
            , command =
                FileSystem.makeDirectory model.fsPermission { recursive = True } cacheFolder
                    |> Task.andThen (\_cacheFolder -> FileSystem.writeFile model.fsPermission res.data model.localPath)
                    |> Task.andThen 
                        (FileSystem.changeAccess
                            model.fsPermission
                            { owner = [ FileSystem.Read, FileSystem.Write, FileSystem.Execute ]
                            , group = [ FileSystem.Read, FileSystem.Execute ]
                            , others = [ FileSystem.Read, FileSystem.Execute ]
                            }
                        )
                    |> Task.andThen (\_binPath -> Stream.sendLine model.stdout "Downloaded")
                    |> Task.attempt CompilerInstalled
            }
        
        CompilerInstalled (Err fsErr) ->
            { model = model
            , command =
                Stream.sendLine model.stderr ("Failed to install binary after download, due to error: " ++ FileSystem.errorToString fsErr)
                    |> Task.execute
            }
        
        CompilerInstalled (Ok {}) ->
            { model = model
            , command =
                runCompiler model
            }

        CompilerRan exitCode ->
            { model = model
            , command =
                Node.exitWithCode exitCode
                    |> Task.execute
            }


downloadBinary : HttpClient.Permission -> String -> Task (HttpClient.Error Bytes) (HttpClient.Response Bytes)
downloadBinary permission url =
    HttpClient.get url
        |> HttpClient.expectBytes
        |> HttpClient.send permission


runCompiler : Model -> Cmd Msg
runCompiler model =
    let
        colorEnvVar =
            if model.useColor then
                Dict.singleton "FORCE_COLOR" "1"
            else
                Dict.singleton "NO_COLOR" "1"
    in
    ChildProcess.spawnAndNotifyOnExit model.cpPermission CompilerRan (model.pathToString model.localPath) model.args <|
        { ChildProcess.defaultSpawnOptions
            | environmentVariables = 
                ChildProcess.MergeWithEnvironmentVariables colorEnvVar
        }
